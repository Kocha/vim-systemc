
# SC_MODULE {{{
snippet   SC_MODULE_SC_CTOR
abbr      SC_MODULE(){ SC_CTOR }
prev_word '^'
    SC_MODULE( ${1:module_name} ){
    
        void process();
        
        SC_CTOR( $1 )
        {
            SC_THREAD( process );
        }
    };${0}

snippet   SC_MODULE_sc_module_name
abbr      SC_MODULE(){ sc_module_name }
prev_word '^'
    SC_MODULE( ${1:module_name} ){
    
        void process();
        
        $1(sc_module_name n)
        : sc_module(n)
        {
            SC_THREAD( process );
        }

        SC_HAS_PROCESS($1);
    };${0}

snippet   SC_METHOD
abbr      SC_METHOD( process )
    SC_METHOD( ${1:process} );${0}

snippet   SC_THREAD
abbr      SC_THREAD( process )
    SC_THREAD( ${1:process} );${0}

snippet   SC_CTHREAD
abbr      SC_CTHREAD( process, clk )
    SC_CTHREAD( ${1:process}, ${2:clk_event} );${0}

snippet   SC_CTHREAD_RST
abbr      SC_CTHREAD( process, clk )_sync_reset
    SC_CTHREAD( ${1:process}, ${2:clk_event} );
    reset_signal_is(${3:reset}, false);${0}

snippet   SC_METHOD_SEN
abbr      SC_METHOD( process ); sensitive <<
    SC_METHOD( ${1:process} );
    sensitive << ${2:event} ;${0}

snippet   SC_THREAD_SEN
abbr      SC_THREAD( process ); sensitive <<
    SC_THREAD( ${1:process} );
    sensitive << ${2:event} ;${0}
# }}}

# Signals {{{
snippet   sc_in
abbr      sc_in< data_type > name;
    sc_in <${1:data_types} > ${2:name};${0}

snippet   sc_out
abbr      sc_out< data_type > name;
    sc_out<${1:data_types} > ${2:name};${0}

snippet   sc_inout
abbr      sc_inout< data_type > name;
    sc_inout<${1:data_types} > ${2:name};${0}
# }}}

# sc_main
snippet   sc_main
abbr      sc_main( ... )
prev_word '^'
    int sc_main(int argc, char* argv[])
    {
        ${0}
        return 0;
    }

# vim: foldmethod=marker

